Chapter 3. Employment   
<br/>
3장. 취업    
<br/>
<br/>
절차적인 프로그래밍과 OOP의 중요한 차이점?
- 책임을 지는 주체가 무엇인가
<br/>

절차적인 프로그래밍에서는 문장, 연산자, 명령문으로 구성된 코드가 가장 중요한 지위 가짐 
- 데이터는 코드가 다가와서 자신을 수정해 주기를 기다리는 수동적인 존재일뿐
<br/>
객체지향 프로그래밍에서는 데이터를 대체하는 객체가 가장 중요한 지위 차지 
<br/>

이번장의 주제를 한 문장으로 요약하면 
거대한 객체, 정적 메서드, NULL 참조, getter, setter, new 연산자에 반대한다는 것입니다. 
<br/>
 ## 3.1 5개 이하의 public 메서드만 노출하세요
클래스의 크기를 정하는 기준으로 public 메서드(protected 메서드 포함)의 개수를 사용권장
=> public 메서드가 많을 수록 클래스가 커짐 
- 적절하다고 생각하는 public 메서드의 수는 5개    

 <br/>

- 클래스를 작게 만들어서 얻는 이득?
: 우아함, 유지보수성, 응집도, 테스트 용이성 향상   
<br/>
## 3.2 정적 메서드를 사용하지 마세요
정적 메서드는 순수악입니다.    
<br/>
- 정적 메서드는 무엇이고, 정적 메서드가 아직도 OOP에 남아있는 이유는 무엇인지 
예시) HTTP 요청을 전송해서 웹 페이지를 로드하는 기능을 구현한 '클래스'
<br/>
````java
class WebPage {
	public static String read(String uri){
    	//HTTP 요청을 만들고
        //UTF-8 문자열로 변환
    }
}

//간편한 사용
String html = WebPage.read("http://www.java.com");
````
 
<br/>
read() 메서드는 정적 메서드의 일종 
더 나은 방식 => 정적 메서드 대신 객체를 사용 


````java
class WebPage{
	private final String uri;
    public String content(){
    	//HTTP 요청을 만들고
        //UTF-8 문자열로 변환한다
    }
}

//위 클래스 사용
String html = new WebPage("http://www.java.com")
  .content();
````
큰 차이가 없어 보임 
오히려 정적 메서드는 더 빠르고 객체 생성과 가비지 컬렉션에 신경쓸 필요 없고 매우 직관적이기 까지. 
<br/>
하지만 정적 메서드는 소프트웨어를 유지보수하기 어렵게 만듬 

<br/>
## 3.2.1 객체 대 컴퓨터 사고(object vs. computer thinking)
<br/>
초창기 프로그래밍 언어( 어셈블리어, C, COBOL 등) 들의 패러다임은 컴퓨터가 우리를 위해 일하고 
우리는 명령어를 제공해서 지시를 내린다는 것 

 
<br/>
이 방식의 장점
- 프로그래머가 CPU와 유사한 방식으로 CPU에게 직접 지시할 수 있다는 점 
프로그램의 흐름은 항상 순차적, 스크립트의 위에서 아래로 흐름 

 
<br/>
이런 순차적인 사고 방식을 가리켜 '컴퓨터 입장에서 생각하기'라고 부름
작은 소프트웨어에서는 문제 없지만 규모 커지면 한계에 직면 

<br/>
````java
(def x (max 5 9))
````
이 최대값을 계산하는 것은 프로그래머의 통제 밖에 있음 
<br/>
x는 최댓값'이다(is a)'라고 정의하는 것이 핵심 
OOP가 절차적 프밍과 차별화 되는 점이 'is a' 입니다. 

 
<br/>
컴퓨터처럼 생각하기에서 : 명령을 제어할 책임이 프로그래머에게 있음 
OOP에서 : 그저 누가 누구인지만 정의, 객체들이 필요할 때 스스로 상호작용하도록 제어를 위임 


 <br/>
OOP 관점 최댓값 계산 코드 : 
````java
class Max implements Number { 
	private final Number a;
    private final Number b;
    public Max(Number left, Number right) {
    	this.a = left;
        this.b = right;
    }
}

//Max 클래스 사용방법
Number x = new Max(5, 9);
````
위 코드는 최댓값을 계산하지 않음 
<br/>
그저 x가 5와 9의 최댓값이라는  (is a) 사실을 정의할 뿐 
<br/>
CPU에게 계산과 관련된 어떤 지시도 내리지 않고, 단순히 객체 생성 
<br/>
이런 측면에서 OOP는 함수형 프로그래밍과 매우 유사 

 
<br/>
반대로, OOP의 정적 메서드는 정확하게 C와 어셈블리어의 서브루틴과 동일 
다음은 정적 메서드를 이용해서 최댓값을 구하는 Java 코드

````java
int x = Math.max(5, 9);
````
형편없는 코드

정적 메서드 사용금지 

<br/>
## 3.2.2 선언형 스타일 대 명령형 스타일 (declarative vs. imperative style)
명령형 프로그래밍 : '프로그램의 상태를 변경하는 문장을 사용해서 계산방식 서술'
선언형 프로그래밍 : '제어 흐름 서술하지 않고 계산로직 표현' 
 
<br/>
명령형 프로그래밍 : 연산을 차례대로 실행
선언형 프로그래밍 : '엔티티'와 엔티티 사이의 '관계'로 구성되는 자연스러운 패러다임 

<br/>
선언형이 더 강력하지만 명령형 프로그래밍이 쉬움 

<br/>
정적 메서드와 무슨 상관?
- 정적 메서드 방식과 객체 방식 둘 다 a와 b를 비교하는 실제 if문을 감싸고 있을 뿐임
- 둘 사이의 차이점은 다른 클래스, 객체, 메서드가 이 기능을 사용하는 방법에 있음 

 <br/>
예시) 두 정수 사이 간격이 있고 그 간격 안에 존재해야 하는 또 다른 정수가 있음 그 정수가 간격 안에 포함되는 지 여부 확인해야함 

## max()가 정적 메서드라면 
````java
public static int between(int l, int r, int x){
	return Math.min(Math.max(l,x),r);
}

int y = Math.between(5,9,13); // 9를 반환
````
기존의 정적 메서드인 Math.min()과 Math.max()를 사용하는 또 다른 정적 메서드인 between()을 추가해야함 
between() 메서드는 호출된 즉시 결과 반환
<br/>
=> 메서드 호출한 시점에 CPU가 즉시 결과 계산함 => 명령형 스타일 


## 선언형 스타일 

````java
class Between implements Number { 
	private final Number num;
    Between(Number left, Number right, Number x) { 
    	this.num = new Min(new Max(left, x), right);
    }
    @Override
    public int intValue() {
    	return this.num.intValue();
    }
}

//사용예제
Number y = new Between(5,9,13); //아직!
````
이 두 방식의 차이점: 
<br/>
- 선언형 스타일 : 아직까지는 CPU에게 숫자를 계산하라고 말하지 않음 
: 프로그래서믄 Between이 무엇인지만 정의하고, 변수 y의 사용자가 intValue()의 값을 계산하는 시점을 결정함

<br/>
## 선언형 방식이 명령형 방식보다 좋은 이유?
- 선언형 방식이 더 빠름 

: 우리가 직접 성능 최적화를 제어할 수 있기 때문

: 인스턴스를 생성하는 데 걸리는 시간이 정적 메서드 호출하는데 걸리는 시간보다 오래걸림 

: 실행경로가 직선적이고 단순한 경우라면 사실 

: 하지만 다수의 정적 메서드를 호출해야 하는 경우 필요한 메서드만 호출할 수 있는 객체 방식 vs.

작업완료 위한 모든 정적 메서드 순차적으로 호출해야하는 방식 

<br/>

````java
//정적메서드 사용 
pulblic void doIt() {
	int x = Math.between(5,9,13);
    if (/* x가 필요한가? */){
    	System.out.println("x=" + x);
    }
}

//선언형 방식 
public void doIt(){
	Integer x = new Between(5,9,13);
    if (/* x가 필요한가? */) {
    	System.out.println("x=" + x);
    }
}
````
- 정적메서드 사용 예제에서는 나중에 x의 값이 필요한지 여부와 무관하게 무조건 x의 값을 계산함 
_CPU는 어떤 경우에도 x의 값이 9라는 사실을 알게됨
<br/>

## 선언형 방식이 더 빠르다
- 두 번째 코드에서는 CPU에게 결과가 실제로 필요한 시점과 위치를 결정하도록 위임하고 CPU는 요청이 있을 경우에만 계산을 실행 
<br/>
OOP에서 선언형 스타일을 선호하는 이유
=> 실행 관점에서 선언형 방식이 더 최적화 되기 때문에 더 빠르다
=> 다형성(코드 블록 사이의 의존성을 끊을 수 있는 능력)

<br/>
예시) min과 max 클래스를 사용하는 대신 if-then-else 구문을 사용하도록 변경 (선언형 방식)

````java
class Between implements Number {
	private final Number num;
    Between(int left, int right, int x){
    	this(new Min(new Max(left, x), right));
    }
    Between(Number number){
    	this.num = number;
    }
}

//다른 알고리즘과 조합
Integer x = new Between(
	new IntegerWithMyOwnAlogrithm(5,9,13)
);
````
<br/>
새롭게 추가한 ctor을 제외하면 앞에 있던 클래스와 거의 동일 
다른 알고리즘과 조합해서 사용가능 
<br/>
Between과 Max, Min은 모두 클래스 이기 때문에 Max와 Min으로부터 Between을 쉽게 분리가능 

 
<br/>
## 객체를 다른 객체로부터 완전히 분리하기 위해서는
메서드나 주ctor 어디에서도 new 연산자를 사용하지 말아야함.
<br/>
예시) 명령형 코드
````java
int y = Math.between(5,9,13);
````
위와 동일한 방법으로 연산을 분리하고 리팩토링 불가 
=> 정적 메서드 between()은 두개의 정적 메서드 min()과 max()를 사용하고 있기 때문에, 
앞서 짠 메서드를 전체적으로 다시 구현하는 방법뿐

<br/>
 ## 선언형 프로그래밍 스타일을 선호하는 두번째 이유 
:선언형 프로그래밍을 이용하면 객체 사이의 결합도를 낮출 수 있음, 우아한 처리 + 유지보수성 

## 선언형 프로그래밍 스타일을 선호하는 세번째 이유 
: 표현력 때문 
선언형 방식은 결과를 얘기함 
명령형 방식은 수행 가능한 한 가지 방법을 얘기함 

<br/>
명령형 방식에서 결과를 예상하기 위해선 머릿속에서 코드를 '실행' 해야함
이에 명령형 방식이 선언형 방식보다 덜 직관적 


````java
//명령형 스타일
Collection<Integer> evens = new LinkedList<>();
for (int  number : numbers) {
	if (number %2==0){
    	evens.add(number);
    }
}

//선언형 스타일
Collection<Integer> evens = new Filtered(
	numbers,
    new Predicate<Integer>() {
    	@Override
        public boolean suitable(Integer number){
        	return number %2== 0;
        }
	}
);
````
명령형 스타일 코드를 이해하기 위해서는 코드 안의 루프를 '마음 속으로 시각화'해야 함 
CPU가 수행해야 하는 일을 코드를 읽는 사람도 동일하게 수행해야함 

 <br/>
선언형 스타일 코드에서 알아야 하는 것은 컬렉션이 '필터링' 되었다는 사실 뿐 
코드에는 구현과 관련된 제수 사항은 감춰져 있고, 오직 행동만 표현됨
 
<br/>
첫번째 코드가 더 읽기 편하다? => 습관의 문제
알고리즘과 실행 대신 객체와 행동의 관점에서 사고한다면 무엇이 올바른지 느껴질 것 

 <br/>
## 선언형 프로그래밍 스타일을 선호하는 네번째 이유 
: 코드 응집도 
<br/>
선언형 스타일 코드에서 evens = new Filterd(...)라는 문장을 통해 evens를 한 줄에 선언했음 
이 경우 '계산'을 책임지는 모든 코드들은 한 곳에 뭉쳐 있으므로 실수로 분리할 수 없음 
그에 비해 명령형 코드는 실수로 코드의 순서를 쉽게 변경할 수 있음_ 오류 가능성 향상 

 

 <br/>
정적 메서드는 객체지향 소프트웨어의 암적인 존재 

<br/>
# 3.2.3 유틸리티 클래스 (Utility classes)
‘유틸리티(utility)’ 클래스 : 말만 클래스지 실제 클래스 x  아님 
: 편의를 위해 다른 메서드들이 사용 하는 정적 메서드들을 모아 놓은 정적 메서드들의 컬렉션

<br/>
가장 유명한 유틸리티 클래스 : java.lang.Math
유틸리티 클래스를 클래스라고 부르기 어려운 이유
: 인스턴스를 생성하지 않기 때문 ! 

예제
````java
class Math {
     private Math() {
     // 의도적으로 공백으로 남김
    }
 public static int max(int a, int b) {
     if (a < b) {
         return b;
     return a;
     }
 }
````
private Math() 이거 ! ctor 보이시죠?
유틸리티 클래스를 구현시, ‘클래스’의 인스턴스가 생성되는 것을 방지위해 
<br/>
private ctor을 추가하는 것이 좋음 
=> 클래스 선언된 메서드 제외한 누구도 인스턴스 생성 불가능 

 <br/>
하지만 이런 유틸리티 클래스는 =>
정적 메서드를 설명하면서 나열했던 모든 단점들 증폭시키는 끔찍한 패턴
가까이 하지 마세요.. 

<br/>
# 3.2.4 싱글톤(Singleton) 패턴 
싱글톤 패턴은 정적 메서드 대신 사용할 수 있는 매우 유명한 개념
싱글톤 안에 - > 하나의 정적 메서드 존재
<br/>
싱글톤의 형태 like seems ( 거의 유사) = 일반적인 객체 
but, 자세히 보면 일반적인 객체와는 매우 다름 

````java
class Math {
 private static Math INSTANCE = new Math();
 private Math() {}
 public static Math getlnstance() { 
	return Math.INSTANCE;
 }
 public int max(int a, int b) { 
	if (a < b) {
 		return b;
 	} 
	return a;
 } 
}
````
여기서 보이는 Math 클래스는 싱글톤의 대표적인 예! 
- Math 클래스의 인스턴스는 오직 하나만 존재 가능 
- 인스턴스의 이름은 INSTANCE이고 getInstance()를 호출해서 접근 가능 

<br/>
=> 하지만, 싱글톤은 안좋다! 
유틸리티 클래스와 싱글톤의 차이점 예제
( 앞서 설명한 싱글톤 클래스와 정확히 동일한 일 수행하는 유틸리티 클래스)

<br/>
````java
class Math {
     private Math() {}
     public static int max(int a, int b) { 
        if (a < b) {
         return b;
     } 
    return a;
     }
 }
 
 Math.max(5,9); //유틸리티 클래스
 Math.getInstance().max(5,9); //싱글톤
````
<br/>
- 정적 메서드, 유틸리티 클래스 기법이 있음에도 싱글톤 패턴의 발명 이유 무엇?
- > 싱글톤은 상태를 캡슐화할 수 있다? (노놉)
-> 싱글톤은 분리 가능한 의존성으로 연결되어있음 <-> 유틸리티 : 분리 불가능, 하드코딩 결합도


예시 
````java
 Math.getlnstance().max(5, 9);
 
 
 Math math = new FakeMath();
 Math.setlnstance(math);

````
첫번째 줄의 코드는 Math 클래스에 결합 -> Math 클래스는 이 코드의 의존성 
- Math클래스가 없다면 동작 안함 ->  Math 클래스를 요청을 처리할 수 있는 상태로 만들어야 함

<br/> 
근데 테스트 동안에 Math.max() 메서드가 실행되지 않도록 하고 싶다면?
예시의 두,세번째 줄의 코드 처럼 구현하면 됨 
=> 내부에 캡슐화된 정적 객체를 교체가능 
=> 캡슐화된 객체를 변경할 수 있기 때문에 싱글톤 > 유틸리티 ! (더 좋음)

<br/>
싱글톤이 유틸리티 클래스보다 낫다?
=> 싱글톤은 전역변수 그 이상도 그 이하도 아님 
=> OOP에는 전역 변수를 위한 자리 없음 

<br/>
=> 전역변수는 순수하게 절차적인 언어위해 존재 
=> 전역변수는 캡슐화를 완벽하게 위반 

Java에서 전역변수 사용할 수 있는 방법 발견 = > 싱글톤 탄생
싱글톤 : 객체지향 페러다임을 잘못 사용한 예 
 
<br/>
대안은? 소프트웨어의 전체 클래스들이 사용해야 하는 기능은 어떻게 구현?
: 캡슐화를 사용, 로그인된 사용자가 필요한 모든 객체 안에 사용자를 캡슐화함 
... 객체는 자신이 캡슐화하고 있는 프로퍼티 이외의 어떤 것도 건드려서는 x 안됨 

<br/>
=> 절대로 싱글톤을 사용하지 마세요.

<br/>
# 3.2.5 함수형 프로그래밍
객체의 크기가 작고, 상태가 변하지 않으며, 정적 메서드도 포함하지 않는다면,
=> 함수형 프로그래밍 (functional programming, FP)은 어때?

<br/>
- 객체를 ‘우아하게’ 만들었다면, 함수와 객체 사이에는 많은 부분이 유사해짐 
=> 그렇다면 왜 객체가 필요할까?

<br/>
이유 : FP보다 OOP의 표현력이 더 뛰어나고 강력함 
=> FP에서는 오직 함수만 사용할 수 있지만 OOP에서는 객체와 메서드를 조합 가능함

<br/>
# 3.2.6 조합 가능한 데코레이터 
조합 가능한 데코레이터는 그저 다른 객체를 감사는 객체일 뿐 
-> 이 데코레이터 객체들을 다중 계층 구조로 구성하기 시작하면 조합 가능해짐

 <br/>
예제 
````java
names = new Sorted(
	new Unuque(
    	new Capitalized(
            new Replaced(
                new FileNames(
                    new Directory(
                        "/var/users/*.xml"
                    )
                   ),
                   "([^.]+\\.xml",
				   "$1"
				)
               )
              )
             );
````
이 코드는 매우 깔끔하면서 객체지향적임 
조합 가능한 데코레이터는 그저 다른 객체를 감싸는 객체일 뿐 
<br/>
이것은 디자인 패턴인 데코레이터일 뿐이지만, 이 데코레이터 객체들을 다중계층 구조로 구성하기 시작하면 다음 예제처럼 조합 가능해짐 

<br/>
# 3.3 인자의 값으로 NULL을 절대 허용하지 마세요 
NULL은 정적 메서드및 가변성과 더불어 객체지향 세계의 골칫거리 중 하나 
이번 섹션에서는 메서드의 인자값으로 NULL을 사용하는 경우만 보겠음 

<br/>
메서드의 설계
````java
public Iterable<File> find(String mask) {
 // 디렉토리를 탐색해서 “*.txt”와 같은 형식의
// 마스크(mask)에 일치하는 모든 파일을 찾는다.
 // 마스크가 NULL인 경우에는 모든 파일을 반환한다 
}
````
디렉토리 - *.txt 모든 파일 찾기 

                  ㄴ String mask 인자가 null 인경우 - 마스크가 없는 <모든 파일 반환>

- 전달할 객체가 없을 때 진짜 객체 대신 NULL을 전달하도록 하는 것은 일반적인 방법

<< null이 있음으로서 findAll() 이라는 다른 메서드를 또 하나 만드는 수고를 하지 않을 수 있음 >>



- NULL을 전달하는 방법은 아래의 두 메서드를 하나로 합칠 수 있는 편리한 방법
````java
public Iterable<File> findAll();
public Iterable<File> find(String mask);
````
<br/>
두개의 메서드를 모두 기억하는 것 보다 null을 전달하는 방식이라면 더 간편 
=> NULL을 사용하는 편이 더 편리하고 경제적인 것처럼 보임 

<br/>
하지만 각각의 객체가 자신의 행동을 온전히 책임진다는 객체 패러다임과는 상반되는 아이디어. 
.( •̀ ω •́ )✧

<br/>
NULL을 허용하는 find() 메서드는 보통 다음과 같이 분기를 처리합니다. 
````java
 public Iterable<File> find(String mask) {
 if (mask == null) {
 // 모든 파일을 찾는다
} else {
 // 마스크를 사용해서 파일을 찾는다
 	}
 }
````
문제가 되는 부분,  mask == null 
이 방식은 mask 객체에게 이야기 하는 대신, 
예의없이 객체를 무시하는 방식입니다. 

 <br/>
객체를 존중한다면, 
````java
public Iterable<File> find(Mask mask) {
 if (mask.emptyO) {
 // 모든 파일을 찾는다
} else {
 // 마스크를 사용해서 파일을 찾는다
}
 }
````
mask.empty()를 사용해서 

 
<br/>
더 개선한다면, 
````java
public Iterable<File> find(Mask mask) {
 Collection<File> files = new LinkedList<>();
 for (File file : /* 모든 파일 */)
 if (mask.matches(file)) { 
files, add (file);
 }
 }
 return files;
 }
````
모든 file들을 다 탐색 한 뒤 mask가 매치 되는 지 확인하는 방식이 있습니다. 
<br/>
 mask 객체를 존중했다면 조건의 존재 여부를 객체 스스로 결정하게 했을 것 
- 스스로 결정 (mask.matches, mask.empty)
- 객체를 추측 (mask == null) 

 <br/>
진짜 객체라면 대화에 응할 것이고 
NULL이면 대응하지 않겠다 는 식으로 객체와 의사소통하면 안됨 
 
<br/>
인자의 값으로 NULL을 허용하면 mask == null과 같은 비교문을 사용할 수 밖에 없음 
- 객체의 '실체'를 확인하는 것말고는 NULL인지 여부를 판단할 수 있는 방법이 없음 
- 이로서 객체의 책임을 빼앗게 됨 ( 외부에서 자신의 데이터를 다뤄주기만을 기대하는 멍청한 자료구조로 
객체를 퇴화시키고 있는 것) 

<br/>
## 절차 프로그래밍의 세계에서는?
서브루틴이 데이터를 조작하는 절차적인 프로그래밍 세계에서의 NULL은 변명의 여지가 있음 
절차적인 세계에서는 인자로 전달된 데이터가 대화가 가능할 정도로 똑똑하지 않음 
데이터를 제공한다 = 메모리 주소(포인터)를 제공한다
<br/>
인자의 첫 번째 바이트 위치를 출력하는 프로그램을 C로 구현한 예
````java
#include <stdio.h> void foo(char* p) {
 printf("Fifth byte is: %x", *(p + 5));
 }
````
foo() 서브루틴은 지정된 메모리 주소(인자로 전달된) 로 이동해서 5번째 바이트를 가져올 것을 CPU에게 요청
But, 우리는 <br/>
주소의 값이 0x00000000인 경우에는 해당 주소에 접근할 것을
CPU 에게 요청하지 않기로 합의 => 어떤 자료구조도 0x00000000인 주소에 저장하 는 것이 불가능하기 때문입

 <br/>
이런 이유로 포인터의 값이 0일 경우에는 이를 NULL이라고 부르고,
실제 주소로 이 값을 사용하지 않기로 모든 프로그래머가 오래 전에 동의했던 것
이 예제처럼( 이 예제는 잘못된 예제) , NULL로부터는 어떤 것도 가져오라고 요청하지 말아야 함 

<br/>
````java
#include <stdio.h>
 void foo(char* p) {
 	if (p == 0) {
 		printf("It’s NULL; there is no data.");
 	} else {
 	printf("Fifth byte is： %x", *(p + 5));
 	}
 }

````
<br/>
깜빡하고 주소 0x00000000에서 데이터를 가져오라고 CPU에게 요청한다면
‘세그멘테이션 오류(segmentation fault)’ 출력 후 CPU가 프로세스 강제 종료   
<br/>
 ***
<br/>
요약 : 메서드 인자로 절대 NULL을 허용하지 마세요! 
<br/>





