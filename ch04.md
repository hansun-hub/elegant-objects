# Chapter 4. Retirement



객체는 그 누구도 객체를 필요로 하지 않는 시점에 종료함</br>
살아있는 동안 때때로 객체는 예외를 던질 수 있음</br>
</br>
 

but, 유지보수 관점에서 부정확한 예외처리보다 나쁜 것은 없음</br>
이번 장에서는 메서드 결과로 반환되는 NULL, 예외 처리, 리소스 획득에 관해 보겠음</br>
</br>
 

## 4.1 절대 NULL을 반환하지 마세요

메서드의 인자에 null을 반환하는 것은 매우 안좋음</br>
- NULL을 반환한다는 것은 객체를 신뢰할 수 없게함</br>
=> 반환된 값이 객체인지부터 확인해야하기 때문에</br>
객체에게 작업을 요청하고 안심하고 의지할 수 없음</br>

</br>
'객체' = 우리가 신뢰하는 엔티티</br>
</br>
객체는 살아있는 유기체</br>
그러니 객체에게 아무 말도 하지 않은 채 우리 마음대로 예외를 던지면 안됨</br>
null을 사용하면 유지보수성이 저하됨 => NULL을 반환하는 방식은 잘못됐으며 보기에도 좋지 않음</br>
</br>
 

## 4.1.1 빠르게 실패하기 vs. 안전하게 실패하기
저자는 빠르게 실패하기 -> 호</br>
안전하게 실패하기 -> 불호</br>
</br> 

안전하게 실패하기</br>
: 어떤 상황이 닥치더라도 소프트웨어는 생존하기 위해 노력함</br>
ex- 디렉토리에 포함된 모든 파일을 나열하도록 요청한 상황에서 해당 디렉토리가 비어있다</br>
안전하게 실패하기에서는 ->  IOException을 던지는 대신, 누군가가 이 상황을 처리할 수 있도록 NULL을 반환</br>
... 아무도 NULL을 반환하는 상황이 오지 않기를 빌며...</br>


빠르게 실패하기</br>
: 문제가 발생하면 바로 실행중단 및 최대한 빨리 예외 던짐</br>
ex- 디렉토리가 비어있다 알게된 순간 바로 IOException을 던짐</br>
: 상황을 구조하지 않는 대신 가능하면 실패를 분명하게함</br>
=> 더 빠르게 문제를 찾을 수록 더 빠르게 실패하고 - 품질향상</br>
더 오래 숨길 수록 문제가 더 커짐</br>

 

## 4.1.2 NULL의 대안
원하는 객체를 찾지 못했을 경우 NULL을 반환하고 싶은 유혹이 큼</br>

NULL을 대체할 수 있는 몇 가지 방법이 3가지 있음</br>
첫번째 방법: 메서드를 두 개로 나누는 것</br>
( 객체의 존재 확인, 객체를 반환) 이렇게 2개</br>
</br>
=> DB에 요청을 두 번 전송하기 때문에 비효율적임</br>
두번째 방법: NULL을 반환하거나 예외 던지는 대신 객체 컬렉션을 반환하는 것</br>
: 빈 컬렉션을 반환하는 건데 기술적으로는 NULL과 크게 다르지 않지만 더 깔끔</br>
</br>
세번째 방법: 널 객체(null object) 디자인 패턴 사용</br>
: 널 객체 패턴에서는 원하는 객체를 발견하지 못할 경우, 겉으로 보기에는 원래의 객체처럼 보이지만</br>
실제로는 다르게 행동하는 객체를 반환함</br>
</br>
요약: NULL을 반환하지 말아라</br>

 
## 4.2 체크 예외(checked exception)만 던지세요

체크 예외와 언체크 예외</br>
-> Java는 두 종류의 예외 모두 제공</br>
언체크 예외를 사용하는 것은 실수이며,</br>
모든 예외는 체크 예외여야 함</br>

</br>
먼저 체크예외와 언체크 예외의 차이점과</br>
예외 '타입'의 용도에 관해 보겠음</br>

 
````java
public byte[] content(File file) throws IOException {
	byte[] array = new byte[1000];
    new FileInputStream(file).read(array);
    return array;
}
```` 

주목할 점 : throws IOException으로 종료됨 </br>
=> 무슨 일이 있어도 content()를 호출하는 쪽에서 IOException 예외를 잡아야 한다는 것 의미함</br>
</br> 

throws lOException</br>
: throws를 통해 호출하는 쪽에 오류 처리 책임을 넘김 > 안전하지 않다는 것을 알리는 것 ></br>
클라이언트로 책임을 전파(escalating) > catch 구문을 통해 반드시 잡아야 하기에 체크 예외에 속함</br>
</br>

## 4.2.1 꼭 필요한 경우가 아니라면 예외를 잡지 마세요 

</br> 
< 상위로 전파하는 것을 추천 ></br>
모든 catch 문에는 납득할 수 있는 이유가 있어야 함 ></br>
반드시 잡아야 하거나 & 다른 선택의 여지가 없는 경우 제외하고 예외 잡아서는 안 됨 ></br>
</br>

이상적 설계 : 애플리케이션 진입점 별로 하나의 catch문만 존재 >> </br>
빠르게 실패하기와 안전하게 실패하기의 원칙을 거의 그대로 적용 >> </br>
정보 은폐로 인해 예외 인지 및 디버깅에 시간 소요가 심함</br>

</br>

< 흐름 제어를 위한 예외 사용(using exceptions for flow control)></br>
실행 경로를 분기시키기 위해 예외 사용 X > 예외는 분기 처리 목적으로 설계되지 않음 >></br>
심각하고 복구 불가능한 상황을 나타내기 위해 설계 > 분기 처리에는 if를 사용하는 것이 적절</br>
</br>

NULL 반환과 흡사한 케이스</br>
> 0 대신 –1과 같은 값 반환은 의미상 NULL과 흡사</br>
> 클라이언트가 반환값 신뢰하지 못하게 됨 4.2.2 항상 예외를 체이닝하세요</br>
> 문제 원인 파악하기가 어려워짐</br>
</br>
잡아서 로깅하기(catching and logging) 은 안티패턴 => 예외 잡는건 정당한 이유가 있을 때만 해야함 </br>

## 4.2.2 항상 예외를 체이닝하세요

- 예외 되던지기(rethrowing)</br>
> 예외를 잡으면 바로 새로운 예외를 던짐</br>
> 낮은 수준의 근본 원인(root cause)를 소프트웨어의 더 높은 수준으로 이동시킴</br>
> 가치 있는 저수준 정보를 유지하는 것이 관건 ( 원래 예외를 절대 무시하지 마라)</br>


## 4.2.3 단 한번만 복구하세요

예외 후 복구 : 빠르게 실패하기와 안전하게 실패하기의 충돌을 다른 각도에서 본 것</br>
> 흐름 제어를 위한 예외 사용의 또 다른 이름</br> 
딱 한 번은 복구해야 한다</br>
</br>
> 가장 높은 곳. 사용자가 애플리케이션과 소통하는 진입점(entry point)에서</br>
> 문제 해결방법 : 사용자에게 문제를 보여주는 것</br>
> 가장 높은 곳에서 잡으면 main 메소드에서 예외를 잡게 됨</br>
> main 밖에서는 JVM이 예외를 잡으면서 stacktrace가 전부 노출</br>
    >> 사용자 친화적이지 못함</br>
</br>
 

## 4.2.4 관점 - 지향 프로그래밍을 사용하세요 

실패한 작업의 재시도</br>
> 위 코드에서는 최대 3번 시도</br>
> 안전하지는 않지만, 즉시 불안정해지지도 않음</br>
> 실용적이나, 최상위 수준에서 한번 잡아야 한다는 앞선 법칙에 위배</br>

</br> 

관점-지향 프로그래밍(aspect-oriented progamming, AOP)</br>
> OOP와 잘 융화되는 패러다임</br>
> 관점(aspect) : 실패 재시도 코드 블록(@RetryOnFailure의 소스 코드 부분)</br>
> AOP : 덜 중요한 기술&메커니즘을 핵심 클래스로부터 분리</br>
    > 코드 중복을 제거</br>


## 4.2.5 하나의 예외 타입만으로도 충분합니다
예외 타입 중복 기능(redundant feature)</br>
> 한번만 복구한다면 어떤 예외든 담을 수 있는 객체 하나로 충분</br>
> 올바르게 예외 체이닝 되었다면 타입을 알 필요가 있는가?</br>


## 4.3 final 이거나 abstract 이거나
상속 </br>
- 강력하지만 자주 남용되는 기술</br>
- 대부분의 경우 캡슐화가 상속보다 더 나은 대안</br>
> 상속이 객체들의 관계를 너무 복잡하게 만듦</br>
>> 가상 메소드??? (virtual method) 가 그 원인</br>
</br>
상속은 하향식 프로세스</br>
> 자식이 부모 클래스의 코드를 계승받음</br>
> EncryptedDocument의 content() 가 바뀜</br>
> Document에서 length() 는 this.content().length(); 임</br>
> EncryptedDocument의 length() <> Document에서 length()</br>
> 이런 식의 메소드 오버라이딩이 문제가 되는 것</br>
    >> 부모가 자식의 코드에 접근 가능하게 함 (Document의 length())</br>
    >> 복잡성 ↑</br>
